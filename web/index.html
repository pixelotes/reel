<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎬 Reel</title>
    <!-- video.js 8.23.3 -->
    <link href="./css/video-js.css" rel="stylesheet" />
    <!-- fullcalendar.js 6.1.19 -->
    <script src='./js/index.global.min.js'></script>
    <!-- codemirror 5.65.20 -->
    <link rel="stylesheet" href="./css/codemirror.min.css">
    <link rel="stylesheet" href="./css/material-darker.min.css">
    
    <style>
        :root {
            --bg-color: #1e1e1e; --text-color: #d4d4d4; --primary-color: #007acc;
            --border-color: #333; --header-bg: #252526; --table-header-bg: #333;
            --table-row-hover: #2a2d2e; --success-color: #4ec9b0; --error-color: #f44747;
            --warning-color: #ffcc02; --info-color: #75beff;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; }
        main { max-width: 1200px; margin: auto; padding: 2rem; }
        a { color: var(--primary-color); text-decoration: none; }
        a:hover { text-decoration: underline; }
        input, select, button, textarea { padding: 0.75rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--header-bg); color: var(--text-color); font-size: 1rem; }
        button { background-color: var(--primary-color); border-color: var(--primary-color); cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        button:focus { outline: 1px solid var(--primary-color); }
        button.secondary { background-color: var(--header-bg); color: var(--text-color); }
        button.danger { background-color: var(--error-color); border-color: var(--error-color); }

        #login-screen { display: flex; align-items: center; justify-content: center; height: 100vh; }
        #login-form { display: flex; flex-direction: column; gap: 1rem; padding: 2rem; background: var(--header-bg); border-radius: 8px; }

        #app-container { display: none; }
        nav { display: flex; gap: 1rem; border-bottom: 1px solid var(--border-color); margin-bottom: 2rem; }
        nav button { background: none; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; color: var(--text-color); border-bottom: 2px solid transparent; }
        nav button.active { border-bottom-color: var(--primary-color); }
        .page { display: none; }
        .page.active { display: block; }

        /* Media Grid Styles */
        .media-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .media-card { background: var(--header-bg); border-radius: 8px; overflow: hidden; position: relative; cursor: pointer; }
        .media-poster { width: 100%; height: 200px; background: var(--border-color); background-size: cover; background-position: center; position: relative; }
        .media-poster::after { content: '🎬'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; opacity: 0.3; }
        .media-info { padding: 1rem; }
        .media-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; }
        .media-meta { font-size: 0.9rem; color: #aaa; margin-bottom: 0.5rem; }
        .media-status { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; }
        .status-pending { background-color: var(--warning-color); color: #000; }
        .status-searching { background-color: var(--info-color); color: #000; }
        .status-downloading { background-color: var(--primary-color); color: #fff; }
        .status-downloaded { background-color: var(--success-color); color: #000; }
        .status-failed { background-color: var(--error-color); color: #fff; }
        .status-skipped { background-color: var(--border-color); color: var(--text-color); }
        .status-tba { background-color: #555; color: var(--text-color); }
        .status-monitoring { background-color: #8a2be2; color: #fff; }
        .status-online { background-color: var(--success-color); color: #000; }
        .status-offline { background-color: var(--error-color); color: #fff; }

        .progress-bar { width: 100%; height: 4px; background: var(--border-color); margin-top: 0.5rem; border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--success-color); transition: width 0.3s ease; }

        /* Add Media Form */
        #add-media-form { background: var(--header-bg); padding: 2rem; border-radius: 8px; margin-bottom: 2rem; }
        #add-media-form .form-row { display: flex; gap: 1rem; margin-bottom: 1rem; }
        #add-media-form .form-row input, #add-media-form .form-row select { flex: 1; }
        #add-media-form .form-row.full-width { flex-direction: column; }
        #add-media-form textarea { min-height: 100px; resize: vertical; }

        /* Search Results */
        .search-results { margin-top: 1rem; }
        .search-result { display: flex; gap: 1rem; padding: 1rem; background: var(--table-row-hover); border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; }
        .search-result:hover { background: var(--border-color); }
        .search-result img { width: 60px; height: 90px; object-fit: cover; border-radius: 4px; }
        .search-result-info { flex: 1; }
        .search-result-title { font-weight: bold; }
        .search-result-meta { font-size: 0.9rem; color: #aaa; }

        /* Manual Search Results */
        .manual-search-result { display: grid; grid-template-columns: 1fr auto auto auto auto auto; gap: 1rem; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .manual-search-result:last-child { border-bottom: none; }
        .manual-search-title { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Modal Styles */
        .modal-backdrop { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal-content { background-color: var(--header-bg); margin: auto; padding: 2rem; border: 1px solid var(--border-color); width: 80%; max-width: 900px; border-radius: 8px; position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-content-video { background-color: var(--header-bg); margin: auto; padding: auto; border: 1px solid var(--border-color); width: auto; max-width: 900px; border-radius: 8px; position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-close { color: #aaa; position: absolute; top: 1rem; right: 1.5rem; font-size: 28px; font-weight: bold; cursor: pointer; z-index: 10;}
        .modal-close:hover, .modal-close:focus { color: var(--text-color); }

        /* Filter Bar */
        .filter-bar { display: flex; gap: 1rem; align-items: center; margin-bottom: 2rem; flex-wrap: wrap; }
        .filter-bar select, .filter-bar input { min-width: 150px; }

        /* TV Show Details */
        .season-details summary { cursor: pointer; font-weight: bold; margin: 1rem 0 0.5rem; }
        .episode-list { display: flex; flex-direction: column; gap: 0.5rem; margin-left: 1rem; }
        .episode-item { display: grid; grid-template-columns: 1fr auto auto auto; align-items: center; gap: 1rem; }

        /* Video Player Styles */
        #video-player-modal .modal-content { width: 90%; max-width: 1200px; padding: 1rem; height: auto; position: relative; }
        .video-js.vjs-fluid, .video-js.vjs-16-9, .video-js.vjs-4-3 { width: 100%; height: auto; }

        /* Loading Overlay */
        #loading-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 9999; justify-content: center; align-items: center; flex-direction: column; gap: 1rem; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Toast Notifications */
        #toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 10px; }
        .toast { padding: 1rem; border-radius: 5px; color: white; min-width: 250px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transform: translateX(100%); transition: all 0.5s ease; cursor: pointer; }
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast.success { background-color: var(--success-color); color: #000; }
        .toast.error { background-color: var(--error-color); }
        .toast.warning { background-color: var(--warning-color); color: #000; }

        /* Settings Modal Form */
        .settings-form { display: flex; flex-direction: column; gap: 1rem; }
        .settings-form .form-row { display: flex; gap: 1rem; align-items: center; }
        .settings-form .form-row label { font-weight: bold; min-width: 120px; }
        .settings-form .form-row select, .settings-form .form-row input { flex: 1; }

        /* Status List */
        .status-list { list-style: none; padding: 0; }
        .status-list li { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border-color); }
        .status-list li:last-child { border-bottom: none; }

        /* Extra search terms */
        #anime-search-terms-list { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .search-term-tag { background-color: var(--primary-color); color: #fff; padding: 0.25rem 0.75rem; border-radius: 1rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .search-term-tag button { background: none; border: none; color: #fff; opacity: 0.7; cursor: pointer; padding: 0; font-size: 1rem; line-height: 1; }
        .search-term-tag button:hover { opacity: 1; }

        /* Settings tab */
        #settings-page .grid-container {
            display: grid;
            grid-template-columns: 70% 1fr; /* Adjust the column widths */
            gap: 2rem;
        }
        .config-editor-container {
            position: relative;
            height: 400px; /* Increased height for better usability */
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--header-bg);
        }
        
        /* CodeMirror Theme Styles */
        .cm-s-material-darker.CodeMirror {
            background-color: var(--header-bg);
            color: var(--text-color);
            height: 100%;
        }
        .cm-s-material-darker .CodeMirror-gutters {
            background: var(--header-bg);
            border-right: 1px solid var(--border-color);
        }
        .CodeMirror-cursor {
            border-left: 1px solid var(--text-color) !important;
        }

        /* Add Media Modal Form Styling */
        #modal-add-media-form {
            display: flex;
            flex-direction: column;
            gap: 1.25rem; /* Adds vertical spacing between all form rows */
        }
        #modal-add-media-form .form-row {
            margin-bottom: 0; /* Remove old margin to rely on the new gap */
        }
        /* Styling for labels within the modal form */
        #modal-add-media-form label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            font-size: 0.9rem;
        }
        /* Flexbox layout for rows containing multiple items */
        #modal-add-media-form .form-row {
            display: flex;
            gap: 1rem; /* Creates space between items in the same row */
        }

        /* Log Viewer Styles */
        #log-container {
            background-color: var(--header-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            height: 60vh;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            color: var(--text-color);
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="toast-container"></div>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Sending to client...</p>
    </div>

    <div id="login-screen">
        <form id="login-form">
            <h2>🎬 Reel Login</h2>
            <input type="password" id="password-input" placeholder="Password" required>
            <button type="submit">Login</button>
            <p id="login-error" style="color:var(--error-color); text-align:center;"></p>
        </form>
    </div>

    <main id="app-container">
        <nav id="nav-buttons">
            <button data-page="media-page" class="active">Media</button>
            <button data-page="calendar-page">Calendar</button>
            <button data-page="settings-page">Settings</button>
            <button data-page="logs-page">Logs</button>
        </nav>

        <div id="media-page" class="page active">
            <div class="filter-bar">
                <select id="status-filter">
                    <option value="all">All Status</option>
                    <option value="pending">Pending</option>
                    <option value="searching">Searching</option>
                    <option value="downloading">Downloading</option>
                    <option value="downloaded">Downloaded</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="failed">Failed</option>
                </select>
                <select id="type-filter">
                    <option value="all">All Types</option>
                    <option value="movie">Movies</option>
                    <option value="tvshow">TV Shows</option>
                    <option value="anime">Anime</option>
                </select>
                <input type="search" id="search-filter" placeholder="Search titles...">
                <button id="refresh-btn">🔄</button>
                <button id="add-media-btn">+ Add Media</button>
            </div>
            <div id="media-grid" class="media-grid"></div>
        </div>

        <div id="calendar-page" class="page">
            <div id='calendar'></div>
        </div>

        <div id="settings-page" class="page">
            <h2>Settings</h2>
            <div style="background: var(--header-bg); padding: 2rem; border-radius: 8px;">
                <div class="grid-container">
                    <div>
                        <h3>Configuration</h3>
                        <div class="config-editor-container">
                            <textarea id="config-display" spellcheck="false"></textarea>
                        </div>
                        <div style="display: flex; gap: 1rem; margin-top: 1rem; justify-content: flex-end;">
                            <button id="save-config-btn">Save Changes</button>
                        </div>
                    </div>
                    <div>
                        <h3>System Status <button id="refresh-status-btn" style="font-size: 0.8rem; padding: 0.2rem 0.5rem;">🔄</button></h3>
                        <ul id="system-status-list" class="status-list">
                            <li><span>Loading...</span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div id="logs-page" class="page">
            <h2>Application Logs</h2>
            <div class="filter-bar">
                <input type="search" id="log-filter" placeholder="Filter logs..." style="flex: 1;">
                <button id="clear-logs-btn" class="danger">Clear Logs</button>
            </div>
            <div id="log-container"></div>
        </div>
    </main>

    <div id="media-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div id="media-detail-content"></div>
        </div>
    </div>

    <div id="manual-search-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div id="manual-search-content"></div>
        </div>
    </div>

    <div id="video-player-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div class="reel-content">
                <video
                    id="reel-player"
                    class="video-js vjs-big-play-centered vjs-fluid"
                    controls
                    preload="auto"
                    data-setup='{"fluid": true, "html5": {"vtt":{"allowNativeVtt": false}}}'
                >
                </video>
            </div>
        </div>
    </div>

    <div id="add-media-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <form id="modal-add-media-form">
                <h2>Add New Media</h2>
                
                <div>
                    <label for="modal-media-type">Media Type</label>
                    <select name="type" id="modal-media-type" required>
                        <option value="movie" selected>Movie</option>
                        <option value="tvshow">TV Show</option>
                        <option value="anime">Anime</option>
                    </select>
                </div>
    
                <div class="form-row">
                    <input type="text" name="search-query" id="modal-search-query" placeholder="Search by title..." required style="flex: 1;">
                    <button type="button" id="modal-search-metadata-btn">Search</button>
                </div>
    
                <div id="modal-metadata-results" class="search-results"></div>
    
                <input type="hidden" name="id" id="modal-id-input">
    
                <div class="form-row">
                    <input type="text" name="title" id="modal-title-input" placeholder="Title" required style="flex: 2;">
                    <input type="number" name="year" id="modal-year-input" placeholder="Year" min="1900" max="2030" style="flex: 1;">
                </div>
                
                <div id="modal-tv-show-options" style="display: none;">
                    <label>Starting Episode</label>
                    <div class="form-row">
                        <select name="start_season" id="modal-start-season-select"></select>
                        <select name="start_episode" id="modal-start-episode-select"></select>
                    </div>
                </div>
    
                <div class="form-row">
                    <div style="flex: 1;">
                        <label for="modal-min-quality">Minimum Quality</label>
                        <select name="min_quality" id="modal-min-quality" required>
                            <option value="360p">360p</option>
                            <option value="480p">480p</option>
                            <option value="720p" selected>720p</option>
                            <option value="1080p">1080p</option>
                        </select>
                    </div>
                    <div style="flex: 1;">
                        <label for="modal-max-quality">Maximum Quality</label>
                        <select name="max_quality" id="modal-max-quality" required>
                            <option value="360p">360p</option>
                            <option value="480p">480p</option>
                            <option value="720p">720p</option>
                            <option value="1080p" selected>1080p</option>
                        </select>
                    </div>
                </div>

            <div>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: normal;">
                    <input type="checkbox" name="auto_download" id="modal-auto-download-checkbox" checked>
                    Start downloading automatically
                </label>
            </div>
    
                <div style="display: flex; justify-content: flex-end; gap: 1rem; margin-top: 1rem;">
                    <button type="button" class="secondary" id="modal-add-cancel-btn">Cancel</button>
                    <button type="submit">Add to Library</button>
                </div>
            </form>
        </div>
    </div>

    <div id="settings-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <form id="media-settings-form" class="settings-form">
                <h2>Media Settings</h2>
                <input type="hidden" id="settings-media-id">
                <div class="form-row">
                    <label for="settings-min-quality">Min Quality</label>
                    <select id="settings-min-quality">
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p">720p</option>
                        <option value="1080p">1080p</option>
                        <option value="1440p">1440p</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                </div>
                <div class="form-row">
                    <label for="settings-max-quality">Max Quality</label>
                    <select id="settings-max-quality">
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p">720p</option>
                        <option value="1080p">1080p</option>
                        <option value="1440p">1440p</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                </div>
                <div class="form-row">
                    <label for="settings-auto-download">Auto Download</label>
                    <input type="checkbox" id="settings-auto-download">
                </div>
                <div class="form-row" style="justify-content: flex-end;">
                    <button type="button" class="secondary" id="settings-cancel-btn">Cancel</button>
                    <button type="submit">Save Changes</button>
                </div>
            </form>
        </div>
    </div>


    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/yaml/yaml.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // App State
            const state = {
                sessionToken: '',
                allMedia: [],
                filteredMedia: [],
                currentMediaId: null,
                calendar: null,
                editor: null, // To hold the CodeMirror instance
            };

            const RESOLUTION_RANK = { "360p": 0, "480p": 1, "720p": 2, "1080p": 3, "1440p": 4, "2160p": 5 };

            // DOM Elements
            const loginScreen = document.getElementById('login-screen');
            const appContainer = document.getElementById('app-container');
            const loginForm = document.getElementById('login-form');
            const mediaGrid = document.getElementById('media-grid');
            const addMediaForm = document.getElementById('add-media-form');
            const mediaTypeSelect = document.getElementById('media-type');
            const tvShowOptions = document.getElementById('tv-show-options');
            const loadingOverlay = document.getElementById('loading-overlay');

            // --- New UI Functions ---
            function updateTVShowOptionsVisibility(typeSelector, optionsContainer) {
                const selectedType = typeSelector.value;
                optionsContainer.style.display = (selectedType === 'tvshow' || selectedType === 'anime') ? 'block' : 'none';
            }

            function setupAddMediaModal() {
                const modal = document.getElementById('add-media-modal');
                const openBtn = document.getElementById('add-media-btn');
                const cancelBtn = document.getElementById('modal-add-cancel-btn');
                const closeBtn = modal.querySelector('.modal-close');
                const form = document.getElementById('modal-add-media-form');

                const closeModal = () => {
                    modal.style.display = 'none';
                    form.reset();
                    document.getElementById('modal-metadata-results').innerHTML = '';
                    document.getElementById('modal-tv-show-options').style.display = 'none';
                };
                
                const modalMediaTypeSelect = document.getElementById('modal-media-type');
                const modalTvShowOptions = document.getElementById('modal-tv-show-options');

                openBtn.addEventListener('click', () => {
                    modal.style.display = 'flex';
                    updateTVShowOptionsVisibility(modalMediaTypeSelect, modalTvShowOptions);
                });
                cancelBtn.addEventListener('click', closeModal);
                closeBtn.addEventListener('click', closeModal);
                window.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
                modalMediaTypeSelect.addEventListener('change', () => updateTVShowOptionsVisibility(modalMediaTypeSelect, modalTvShowOptions));
                
                document.getElementById('modal-search-metadata-btn').addEventListener('click', searchMetadataInModal);
                form.addEventListener('submit', addMediaFromModal);
            }

            function syncQualitySelectors(minSelector, maxSelector) {
                minSelector.addEventListener('change', () => {
                    if (RESOLUTION_RANK[minSelector.value] > RESOLUTION_RANK[maxSelector.value]) {
                        maxSelector.value = minSelector.value;
                    }
                });

                maxSelector.addEventListener('change', () => {
                    if (RESOLUTION_RANK[maxSelector.value] < RESOLUTION_RANK[minSelector.value]) {
                        minSelector.value = maxSelector.value;
                    }
                });
            }

            function showLoading(show) {
                loadingOverlay.style.display = show ? 'flex' : 'none';
            }

            function showToast(message, type = 'success', duration = 5000) {
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                container.appendChild(toast);
                toast.onclick = () => toast.classList.remove('show');

                setTimeout(() => toast.classList.add('show'), 10);

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration);
            }

            // Authentication
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const passwordInput = document.getElementById('password-input');
                const loginError = document.getElementById('login-error');
                loginError.textContent = '';
                
                try {
                    const response = await fetch('/api/v1/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ password: passwordInput.value })
                    });
                    
                    if (!response.ok) throw new Error('Incorrect password');
                    
                    const { token } = await response.json();
                    state.sessionToken = token;
                    loginScreen.style.display = 'none';
                    appContainer.style.display = 'block';
                    initializeApp();
                } catch (error) {
                    loginError.textContent = error.message;
                }
            });

            // App Initialization
            function initializeApp() {
                setupNavigation();
                setupAddMediaModal(); // Setup the new modal
                setupFilters();
                // setupAddMediaForm(); // Keep old tab for now
                setupModal('media-modal');
                setupModal('manual-search-modal');
                setupModal('settings-modal', 'settings-cancel-btn');
                setupVideoPlayerModal();
                setupSettingsForm();
                refreshData();
                checkSystemStatus();
                setInterval(refreshData, 2000);
                document.getElementById('refresh-status-btn').addEventListener('click', checkSystemStatus);
                document.getElementById('save-config-btn').addEventListener('click', saveConfig);
                
                document.getElementById('test-torrent-btn').addEventListener('click', async () => { /* Implement test logic */ });
                document.getElementById('test-indexer-btn').addEventListener('click', async () => { /* Implement test logic */ });
                document.getElementById('clear-failed-btn').addEventListener('click', async () => {
                    showToast('Clear all failed media? Click to confirm.', 'warning', 5000)
                    document.getElementById('toast-container').lastChild.onclick = async () => {
                        try {
                            const response = await fetchWithAuth('/api/v1/media/clear-failed', { method: 'POST' });
                            if (response.ok) { showToast('Failed items cleared.'); loadMedia(); }
                        } catch (error) { showToast('Failed to clear items.', 'error'); }
                    };
                });

                // Sync quality selectors
                // const minQualityAdd = document.getElementById('min-quality');
                // const maxQualityAdd = document.getElementById('max-quality');
                // syncQualitySelectors(minQualityAdd, maxQualityAdd);
                const minQualitySettings = document.getElementById('settings-min-quality');
                const maxQualitySettings = document.getElementById('settings-max-quality');
                syncQualitySelectors(minQualitySettings, maxQualitySettings);
                
                // Sync quality selectors for the new modal
                const minQualityModal = document.getElementById('modal-min-quality');
                const maxQualityModal = document.getElementById('modal-max-quality');
                syncQualitySelectors(minQualityModal, maxQualityModal);
            }

            function setupNavigation() {
                document.getElementById('nav-buttons').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        const pageId = e.target.dataset.page;
                        document.querySelector('#nav-buttons .active').classList.remove('active');
                        e.target.classList.add('active');
                        document.querySelectorAll('.page').forEach(p => p.classList.toggle('active', p.id === pageId));

                        if (pageId === 'media-page') {
                            loadMedia();
                        } else if (pageId === 'settings-page') {
                            loadConfig();
                            checkSystemStatus();
                        } else if (pageId === 'calendar-page') {
                            initializeCalendar();
                        } else if (pageId === 'logs-page') {
                            initializeLogViewer();
                        }
                    }
                });
            }

            function setupFilters() {
                const statusFilter = document.getElementById('status-filter');
                const typeFilter = document.getElementById('type-filter');
                const searchFilter = document.getElementById('search-filter');
                const refreshBtn = document.getElementById('refresh-btn');

                [statusFilter, typeFilter, searchFilter].forEach(filter => {
                    filter.addEventListener('change', filterMedia);
                    filter.addEventListener('input', filterMedia);
                });

                refreshBtn.addEventListener('click', loadMedia);
            }

            /*
            function setupAddMediaForm() {
                const searchBtn = document.getElementById('search-metadata-btn');
                searchBtn.addEventListener('click', searchMetadata);
                addMediaForm.addEventListener('submit', addMedia); 
                mediaTypeSelect.addEventListener('change', () => updateTVShowOptionsVisibility(mediaTypeSelect, tvShowOptions));
                updateTVShowOptionsVisibility(mediaTypeSelect, tvShowOptions); // Check on initial load
            }
            */

            function setupModal(modalId, cancelBtnId = null) {
                const modal = document.getElementById(modalId);
                const closeBtn = modal.querySelector('.modal-close');
                
                const closeModal = () => {
                    modal.style.display = 'none';
                    if (modalId === 'media-modal') state.currentMediaId = null;
                };

                closeBtn.addEventListener('click', closeModal);
                if (cancelBtnId) {
                    document.getElementById(cancelBtnId).addEventListener('click', closeModal);
                }
                window.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
            }

            function setupVideoPlayerModal() {
                const modal = document.getElementById('video-player-modal');
                const closeBtn = modal.querySelector('.modal-close');
                const player = videojs('reel-player');

                const closeModal = () => {
                    modal.style.display = 'none';
                    player.pause();
                    player.src(''); 
                    const tracks = player.remoteTextTracks();
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        player.removeRemoteTextTrack(tracks[i]);
                    }
                };

                closeBtn.addEventListener('click', closeModal);
                window.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.style.display === 'flex') closeModal();
                });
            }

            function setupSettingsForm() {
                const form = document.getElementById('media-settings-form');
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const mediaId = document.getElementById('settings-media-id').value;
                    const minQuality = document.getElementById('settings-min-quality').value;
                    const maxQuality = document.getElementById('settings-max-quality').value;
                    const autoDownload = document.getElementById('settings-auto-download').checked;

                    if (RESOLUTION_RANK[minQuality] > RESOLUTION_RANK[maxQuality]) {
                        showToast('Minimum quality cannot be higher than maximum quality.', 'error');
                        return;
                    }
                    
                    try {
                        const response = await fetchWithAuth(`/api/v1/media/${mediaId}/settings`, {
                            method: 'POST',
                            body: { min_quality: minQuality, max_quality: maxQuality, auto_download: autoDownload }
                        });
                        if (!response.ok) throw new Error('Failed to save settings');

                        showToast('Settings updated successfully!');
                        document.getElementById('settings-modal').style.display = 'none';
                        loadMedia(); // Refresh to show new settings
                    } catch (error) {
                        showToast(error.message, 'error');
                    }
                });
            }
            
            async function refreshData() {
                const oldMediaData = JSON.stringify(state.allMedia);
                await loadMedia();
                const newMediaData = JSON.stringify(state.allMedia);

                const modal = document.getElementById('media-modal');
                if (modal.style.display === 'flex' && state.currentMediaId) {
                    if (oldMediaData !== newMediaData) {
                        const media = state.allMedia.find(m => m.id === state.currentMediaId);
                        if(media) {
                           updateMediaDetails(media);
                           updateEpisodeStatuses(state.currentMediaId);
                        }
                    }
                }
            }
            
            async function updateMediaDetails(media) {
                const modal = document.getElementById('media-modal');
                const statusEl = modal.querySelector('#detail-status');
                if (statusEl) {
                    statusEl.className = `media-status status-${media.status}`;
                    statusEl.textContent = media.status;
                }
                const progressContainer = modal.querySelector('#detail-progress-container');
                if(progressContainer) {
                    if (media.status === 'downloading') {
                        progressContainer.style.display = 'block';
                        modal.querySelector('#detail-progress-fill').style.width = `${media.progress * 100}%`;
                        modal.querySelector('#detail-progress-text').textContent = `Progress: ${Math.round(media.progress * 100)}%`;
                    } else {
                        progressContainer.style.display = 'none';
                    }
                }
            }

            async function updateEpisodeStatuses(mediaId) {
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/tv-details`);
                    if (response.ok) {
                        const show = await response.json();
                        const modal = document.getElementById('media-modal');
                        show.seasons.forEach(season => {
                            season.episodes.forEach(ep => {
                                const episodeEl = modal.querySelector(`.episode-item[data-season-number="${season.season_number}"][data-episode-number="${ep.episode_number}"]`);
                                if (episodeEl) {
                                    const statusEl = episodeEl.querySelector('.media-status');
                                    if (statusEl.textContent.toLowerCase() !== ep.status.toLowerCase()) {
                                        statusEl.className = `media-status status-${ep.status}`;
                                        statusEl.textContent = ep.status;
                                    }
                                }
                            });
                        });
                    }
                } catch (e) {
                    console.error("Could not update episode statuses", e);
                }
            }

            async function fetchWithAuth(url, options = {}) {
                const headers = { ...options.headers };
                headers['Authorization'] = `Bearer ${state.sessionToken}`;
                if (options.body && typeof options.body === 'object') {
                    headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(options.body);
                }
                const response = await fetch(url, { ...options, headers });
                if (response.status === 401) window.location.reload();
                return response;
            }

            async function loadMedia() {
                try {
                    const response = await fetchWithAuth('/api/v1/media');
                    if (response.ok) {
                        const newMedia = await response.json();
                        if (JSON.stringify(newMedia) !== JSON.stringify(state.allMedia)) {
                           state.allMedia = newMedia;
                           filterMedia();
                        }
                    }
                } catch (error) {
                    console.error('Failed to load media:', error);
                }
            }

            /*
            async function addMedia(e) {
                e.preventDefault();
                const formData = new FormData(e.target);
                const minQuality = formData.get('min_quality');
                const maxQuality = formData.get('max_quality');

                if (RESOLUTION_RANK[minQuality] > RESOLUTION_RANK[maxQuality]) {
                    showToast('Minimum quality cannot be higher than maximum quality.', 'error');
                    return;
                }
                
                try {
                    const body = {
                        type: formData.get('type'), title: formData.get('title'),
                        year: parseInt(formData.get('year')), id: formData.get('id'),
                        language: formData.get('language'), min_quality: minQuality, max_quality: maxQuality,
                        auto_download: document.getElementById('auto-download-checkbox').checked,
                    };
                    if (body.type === 'tvshow' || body.type === 'anime') {
                        body.start_season = parseInt(formData.get('start_season'));
                        body.start_episode = parseInt(formData.get('start_episode'));
                    }
                    const response = await fetchWithAuth('/api/v1/media', { method: 'POST', body: body });
                    if (response.ok) {
                        showToast('Media added successfully!');
                        e.target.reset();
                        document.getElementById('metadata-results').innerHTML = '';
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to add media');
                    }
                } catch (error) {
                    showToast(`Error: ${error.message}`, 'error');
                }
            }
            */

            async function addMediaFromModal(e) {
                e.preventDefault();
                const form = e.target;
                const minQuality = form.querySelector('#modal-min-quality').value;
                const maxQuality = form.querySelector('#modal-max-quality').value;

                if (RESOLUTION_RANK[minQuality] > RESOLUTION_RANK[maxQuality]) {
                    showToast('Minimum quality cannot be higher than maximum quality.', 'error');
                    return;
                }
                
                try {
                    const body = {
                        type: form.querySelector('#modal-media-type').value,
                        title: form.querySelector('#modal-title-input').value,
                        year: parseInt(form.querySelector('#modal-year-input').value),
                        id: form.querySelector('#modal-id-input').value,
                        min_quality: minQuality,
                        max_quality: maxQuality,
                        auto_download: form.querySelector('#modal-auto-download-checkbox').checked,
                    };
                    if (body.type === 'tvshow' || body.type === 'anime') {
                        body.start_season = parseInt(form.querySelector('#modal-start-season-select').value);
                        body.start_episode = parseInt(form.querySelector('#modal-start-episode-select').value);
                    }

                    const response = await fetchWithAuth('/api/v1/media', { method: 'POST', body: body });
                    
                    if (response.ok) {
                        showToast('Media added successfully!');
                        document.getElementById('add-media-modal').style.display = 'none';
                        form.reset();
                        document.getElementById('modal-metadata-results').innerHTML = '';
                        loadMedia(); // Refresh media grid
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to add media');
                    }
                } catch (error) {
                    showToast(`Error: ${error.message}`, 'error');
                }
            }

            /*
            async function searchMetadata() {
                const query = document.getElementById('search-query').value;
                const type = document.getElementById('media-type').value;
                const resultsContainer = document.getElementById('metadata-results');
                if (!query) return;
                resultsContainer.innerHTML = '<p>Searching...</p>';
                try {
                    const response = await fetchWithAuth(`/api/v1/search-metadata?q=${encodeURIComponent(query)}&type=${type}`);
                    if (response.ok) {
                        const results = await response.json();
                        displayMetadataResults(results, 'tab');
                    } else {
						const error = await response.json();
                        resultsContainer.innerHTML = `<p style="color:var(--error-color)">Search failed: ${error.error}</p>`;
                    }
                } catch (error) {
                    resultsContainer.innerHTML = '<p style="color:var(--error-color)">Search error</p>';
                }
            }
            */
            
            async function searchMetadataInModal() {
                const query = document.getElementById('modal-search-query').value;
                const type = document.getElementById('modal-media-type').value;
                const resultsContainer = document.getElementById('modal-metadata-results');
                if (!query) return;
                resultsContainer.innerHTML = '<p>Searching...</p>';
                try {
                    const response = await fetchWithAuth(`/api/v1/search-metadata?q=${encodeURIComponent(query)}&type=${type}`);
                    if (response.ok) {
                        const results = await response.json();
                        displayMetadataResults(results, 'modal');
                    } else {
						const error = await response.json();
                        resultsContainer.innerHTML = `<p style="color:var(--error-color)">Search failed: ${error.error}</p>`;
                    }
                } catch (error) {
                    resultsContainer.innerHTML = '<p style="color:var(--error-color)">Search error</p>';
                }
            }

            function displayMetadataResults(results, target = 'tab') {
                const container = document.getElementById(target === 'modal' ? 'modal-metadata-results' : 'metadata-results');
                if (!results || results.length === 0) {
                    container.innerHTML = '<p>No results found</p>';
                    return;
                }
                container.innerHTML = results.map(item => `
                    <div class="search-result" onclick="selectMetadataItem(this, ${JSON.stringify(item).replace(/"/g, '&quot;')}, '${target}')">
                        ${item.poster_url ? `<img src="${item.poster_url}" alt="${item.title}">` : '<div style="width:60px;height:90px;background:var(--border-color);border-radius:4px;"></div>'}
                        <div class="search-result-info">
                            <div class="search-result-title">${item.title}</div>
                            <div class="search-result-meta">${item.year} • ${item.overview ? item.overview.substring(0, 100) + '...' : 'No description'}</div>
                        </div>
                    </div>
                `).join('');
            }

            window.selectMetadataItem = function(element, item, target = 'tab') {
                const prefix = target === 'modal' ? 'modal-' : '';
                document.getElementById(`${prefix}title-input`).value = item.title;
                document.getElementById(`${prefix}year-input`).value = item.year;
                document.getElementById(`${prefix}id-input`).value = item.id;
                document.getElementById(`${prefix}metadata-results`).innerHTML = '';

                const currentMediaType = document.getElementById(`${prefix}media-type`).value;
                if (currentMediaType === 'tvshow' || currentMediaType === 'anime') {
                    populateTVEpisodeSelectors(item.seasons, target);
                }
            };
            
            function populateTVEpisodeSelectors(seasons, target = 'tab') {
                const prefix = target === 'modal' ? 'modal-' : '';
                const seasonSelect = document.getElementById(`${prefix}start-season-select`);
                const episodeSelect = document.getElementById(`${prefix}start-episode-select`);
                seasonSelect.innerHTML = '';
                episodeSelect.innerHTML = '';
                const seasonNumbers = Object.keys(seasons).map(Number).sort((a,b) => a - b);
                for (const seasonNum of seasonNumbers) {
                    seasonSelect.innerHTML += `<option value="${seasonNum}">Season ${seasonNum}</option>`;
                }
                function updateEpisodes() {
                    const selectedSeason = seasonSelect.value;
                    episodeSelect.innerHTML = '';
                    if (seasons && seasons[selectedSeason]) {
                        seasons[selectedSeason].forEach(ep => {
                            episodeSelect.innerHTML += `<option value="${ep.episode_number}">Episode ${ep.episode_number} - ${ep.title}</option>`;
                        });
                    }
                }
                seasonSelect.addEventListener('change', updateEpisodes);
                updateEpisodes();
            }

            function filterMedia() {
                const statusFilter = document.getElementById('status-filter').value;
                const typeFilter = document.getElementById('type-filter').value;
                const searchFilter = document.getElementById('search-filter').value.toLowerCase();
                state.filteredMedia = state.allMedia.filter(media => {
                    if (statusFilter !== 'all' && media.status !== statusFilter) return false;
                    if (typeFilter !== 'all' && media.type !== typeFilter) return false;
                    if (searchFilter && !media.title.toLowerCase().includes(searchFilter)) return false;
                    return true;
                });
                renderMediaGrid();
            }

            function renderMediaGrid() {
                if (!state.allMedia) {
                    mediaGrid.innerHTML = '<p>Loading media...</p>';
                    return;
                }
                if (state.filteredMedia.length === 0) {
                    mediaGrid.innerHTML = '<p>No media found. Add some media to get started!</p>';
                    return;
                }
                mediaGrid.innerHTML = state.filteredMedia.map(media => `
                    <div class="media-card" data-media-id="${media.id}">
                        <div class="media-poster" style="${media.poster_url ? `background-image: url('${media.poster_url}')` : ''}"></div>
                        <div class="media-info">
                            <div class="media-title">${media.title}</div>
                            <div class="media-meta">${media.year} • ${media.type.charAt(0).toUpperCase() + media.type.slice(1)}</div>
                            <span class="media-status status-${media.status}">${media.status}</span>
                            ${media.status === 'downloading' ? `<div class="progress-bar"><div class="progress-fill" style="width: ${media.progress * 100}%"></div></div><div style="font-size: 0.8rem;">${Math.round(media.progress * 100)}%</div>` : ''}
                        </div>
                    </div>
                `).join('');
                document.querySelectorAll('.media-card').forEach(card => {
                    card.addEventListener('click', () => showMediaDetails(parseInt(card.dataset.mediaId)));
                });
            }

            async function showMediaDetails(mediaId) {
                state.currentMediaId = mediaId;
                const media = state.allMedia.find(m => m.id === mediaId);
                if (!media) return;
                const modal = document.getElementById('media-modal');
                const content = document.getElementById('media-detail-content');
                content.innerHTML = '<h2>Loading...</h2>';
                modal.style.display = 'flex';

                let tvShowDetailsHtml = '';
                if (media.type === 'tvshow' || media.type === 'anime') {
                    try {
                        const response = await fetchWithAuth(`/api/v1/media/${mediaId}/tv-details`);
                        if (response.ok) {
                            const show = await response.json();
                            tvShowDetailsHtml = `<h4>Seasons</h4><div style="max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 4px;">
                                ${show.seasons.map(season => `<details class="season-details" data-season-number="${season.season_number}"><summary>Season ${season.season_number}</summary><div class="episode-list">
                                ${season.episodes.map(ep => `<div class="episode-item" data-season-number="${season.season_number}" data-episode-number="${ep.episode_number}"><span>${ep.episode_number}. ${ep.title} <em style="color:#aaa; font-size: 0.8rem;">(${ep.air_date})</em></span><span class="media-status status-${ep.status}">${ep.status}</span><button class="secondary" onclick="manualEpisodeSearch(${media.id}, ${season.season_number}, ${ep.episode_number})">🔍</button><button class="secondary" ${ep.status === 'downloaded' ? '' : 'disabled style="opacity: 0.4;"'} onclick="playVideo(${media.id}, ${season.season_number}, ${ep.episode_number})">▶️</button></div>`).join('')}</div></details>`).join('')}</div>`;
                        }
                    } catch (e) { tvShowDetailsHtml = '<p style="color:var(--error-color)">Could not load season details.</p>'; }
                }
                
                let animeSearchTermsHtml = '';
                if (media.type === 'anime') {
                    animeSearchTermsHtml = `
                        <div id="anime-search-terms-section" style="margin-top: 1rem;">
                            <h4>Alternative Search Terms</h4>
                            <div id="anime-search-terms-list"></div>
                            <div class="form-row" style="margin-top: 0.5rem;">
                                <input type="text" id="new-search-term-input" placeholder="Add a new search term...">
                                <button type="button" onclick="addSearchTerm(${media.id})">Add</button>
                            </div>
                        </div>
                    `;
                }
                
                content.innerHTML = `<h2>${media.title} (${media.year}) ${media.status === 'downloaded' ? `<button class="secondary" style="font-size: 1rem; padding: 0.2rem 0.5rem;" onclick="playVideo(${media.id})">▶️ Play</button>` : ''}</h2>
                    <div style="display: flex; gap: 2rem; margin-bottom: 2rem;">
                        ${media.poster_url ? `<img src="${media.poster_url}" alt="${media.title}" style="width: 200px; border-radius: 8px;">` : ''}
                        <div style="flex: 1;"><p><strong>Type:</strong> ${media.type.charAt(0).toUpperCase() + media.type.slice(1)}</p><p><strong>Quality Range:</strong> ${media.min_quality} - ${media.max_quality}</p><p><strong>Status:</strong> <span id="detail-status" class="media-status status-${media.status}">${media.status}</span></p><div id="detail-progress-container" style="display: ${media.status === 'downloading' ? 'block' : 'none'};"><div class="progress-bar" style="height: 10px;"><div id="detail-progress-fill" class="progress-fill" style="width: ${media.progress * 100}%"></div></div><p id="detail-progress-text"><strong>Progress:</strong> ${Math.round(media.progress * 100)}%</p></div><p><strong>Added:</strong> ${new Date(media.added_at).toLocaleString()}</p><div id="detail-completed-at">${media.completed_at ? `<p><strong>Completed:</strong> ${new Date(media.completed_at).toLocaleString()}</p>` : ''}</div></div></div>
                    ${media.overview ? `<p><strong>Overview:</strong></p><div style="max-height: 100px; overflow-y: auto;">${media.overview}</div>` : ''}
                    ${tvShowDetailsHtml}
                    ${animeSearchTermsHtml}
                    <div style="display: flex; gap: 1rem; margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                        ${media.type === 'movie' && media.status !== 'downloading' && media.status !== 'downloaded' ? `<button onclick="manualMovieSearch(${media.id})">🔍 Manual Search</button>` : ''}
                        ${media.status === 'failed' || media.status === 'pending' ? `<button onclick="retryMedia(${media.id})">🔄 Retry</button>` : ''}
                        <button onclick="showMediaSettingsModal(${media.id})">⚙️ Config</button>
                        <button onclick="deleteMedia(${media.id})" class="danger">🗑️ Delete</button>
                    </div>`;

                if (media.type === 'anime') {
                    loadAnimeSearchTerms(mediaId);
                }
            };

            window.showMediaSettingsModal = (mediaId) => {
                const media = state.allMedia.find(m => m.id === mediaId);
                if (!media) return;

                document.getElementById('settings-media-id').value = media.id;
                document.getElementById('settings-min-quality').value = media.min_quality;
                document.getElementById('settings-max-quality').value = media.max_quality;
                document.getElementById('settings-auto-download').checked = media.auto_download;

                document.getElementById('settings-modal').style.display = 'flex';
            };
            
            window.playVideo = function(mediaId, seasonNumber = 0, episodeNumber = 0) {
                const modal = document.getElementById('video-player-modal');
                const player = videojs('reel-player');
                const existingTracks = player.remoteTextTracks();
                for (let i = existingTracks.length - 1; i >= 0; i--) {
                    player.removeRemoteTextTrack(existingTracks[i]);
                }
                let videoUrl = `/api/v1/stream/video/${mediaId}${seasonNumber > 0 ? `?season=${seasonNumber}&episode=${episodeNumber}`:''}`;
                player.src({ src: videoUrl, type: 'video/mp4' });
                player.ready(() => loadAllSubtitles(player, mediaId, seasonNumber, episodeNumber));
                modal.style.display = 'flex';
                player.play();
            };

            async function loadAllSubtitles(player, mediaId, seasonNumber, episodeNumber) {
                try {
                    const params = new URLSearchParams();
                    if (seasonNumber > 0) params.append('season', seasonNumber);
                    if (episodeNumber > 0) params.append('episode', episodeNumber);
                    const subtitlesListUrl = `/api/v1/subtitles/${mediaId}/available?${params.toString()}`;
                    const subtitlesListResponse = await fetchWithAuth(subtitlesListUrl);
                    if (!subtitlesListResponse.ok) return;
                    const availableSubtitles = await subtitlesListResponse.json();
                    if (!availableSubtitles || availableSubtitles.length === 0) return;
                    availableSubtitles.forEach(async (sub, i) => {
                        params.append('lang', sub.language);
                        const subUrl = `/api/v1/stream/subtitles/${mediaId}?${params.toString()}`;
                        const response = await fetchWithAuth(subUrl);
                        if (!response.ok) return;
                        const vtt = await response.text(), blob = new Blob([vtt], { type: 'text/vtt' });
                        player.addRemoteTextTrack({ kind:'subtitles', src:URL.createObjectURL(blob), srclang:sub.language, label:sub.label, default: i===0 }, false);
                    });
                } catch (error) { console.log('Could not load subtitles:', error); }
            }

            window.manualMovieSearch = async function(mediaId) {
                const modal = document.getElementById('manual-search-modal');
                const content = document.getElementById('manual-search-content');
                content.innerHTML = '<p>Searching...</p>';
                modal.style.display = 'flex';
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/search`);
                    if (!response.ok) throw new Error('Search failed');
                    const results = await response.json();
                    displayManualSearchResultsInModal(results, (r) => manualDownload(mediaId, r));
                } catch (error) { content.innerHTML = `<p style="color:var(--error-color)">Error: ${error.message}</p>`; }
            };

            window.manualEpisodeSearch = async function(mediaId, seasonNumber, episodeNumber) {
                const modal = document.getElementById('manual-search-modal');
                const content = document.getElementById('manual-search-content');
                content.innerHTML = '<p>Searching...</p>';
                modal.style.display = 'flex';
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/season/${seasonNumber}/episode/${episodeNumber}/search`);
                    if (!response.ok) throw new Error('Search failed');
                    const results = await response.json();
                    displayManualSearchResultsInModal(results, (r) => manualEpisodeDownload(mediaId, seasonNumber, episodeNumber, r));
                } catch (error) { content.innerHTML = `<p style="color:var(--error-color)">Error: ${error.message}</p>`; }
            };

            function displayManualSearchResultsInModal(results, downloadCallback) {
                const content = document.getElementById('manual-search-content');
                if (!results || results.length === 0) { content.innerHTML = '<p>No results found.</p>'; return; }
                content.innerHTML = `<h4>Manual Search Results</h4><div style="max-height: 400px; overflow-y: auto;">
                    ${results.map(r => `<div class="manual-search-result"><span class="manual-search-title" title="${r.Title}">${r.Title}</span><span>${(r.Size/(1024*1024)).toFixed(2)} MB</span><span style="color:var(--success-color);">▲ ${r.Seeders}</span><span style="color:var(--error-color);">▼ ${r.Leechers}</span><span>${r.Score}</span><button class="secondary" data-result='${JSON.stringify(r).replace(/'/g, "\\'")}'>Download</button></div>`).join('')}</div>`;
                content.querySelectorAll('button').forEach(b => b.addEventListener('click', () => downloadCallback(JSON.parse(b.dataset.result))));
            }

            window.manualDownload = async function(mediaId, result) {
                showLoading(true);
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/download`, { method: 'POST', body: result });
                    if (!response.ok) throw new Error('Failed to send to client');
                    showToast('Torrent sent to download client!');
                    document.getElementById('manual-search-modal').style.display = 'none';
                    loadMedia();
                } catch (error) { showToast(`Error: ${error.message}`, 'error'); } 
                finally { showLoading(false); }
            };

            window.manualEpisodeDownload = async function(mediaId, seasonNumber, episodeNumber, result) {
                showLoading(true);
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/season/${seasonNumber}/episode/${episodeNumber}/download`, { method: 'POST', body: result });
                    if (!response.ok) throw new Error('Failed to send to client');
                    const body = await response.json();
                    if (body.status.includes('fallback')) showToast(body.message, 'warning');
                    else showToast(body.message || 'Torrent sent to download client!');
                    document.getElementById('manual-search-modal').style.display = 'none';
                    loadMedia();
                } catch (error) { showToast(`Error: ${error.message}`, 'error'); } 
                finally { showLoading(false); }
            };

            window.retryMedia = async function(mediaId) {
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/retry`, { method: 'POST' });
                    if (response.ok) {
                        showToast('Retry request sent.');
                        loadMedia();
                        document.getElementById('media-modal').style.display = 'none';
                    }
                } catch (error) { showToast('Failed to retry media.', 'error'); }
            };

            window.deleteMedia = async function(mediaId) {
                showToast('Are you sure? Click to confirm delete.', 'warning', 5000)
                document.getElementById('toast-container').lastChild.onclick = async () => {
                     try {
                        const response = await fetchWithAuth(`/api/v1/media/${mediaId}`, { method: 'DELETE' });
                        if (response.ok) {
                            showToast('Media deleted.');
                            state.allMedia = state.allMedia.filter(m => m.id !== mediaId);
                            filterMedia();
                            document.getElementById('media-modal').style.display = 'none';
                        }
                    } catch (error) { showToast('Failed to delete media.', 'error'); }
                };
            };

            async function checkSystemStatus() {
                const statusList = document.getElementById('system-status-list');
                statusList.innerHTML = '<li><span>Checking...</span></li>';
                const metadataAPI = {
                    'tmdb': 'https://api.themoviedb.org/3/search/movie?api_key=test',
                    'imdb': 'https://www.imdb.com/',
                    'tvmaze': 'https://api.tvmaze.com/',
                    'anilist': 'https://graphql.anilist.co/',
                    'trakt': 'https://api.trakt.tv/'
                };

                try {
                    const response = await fetchWithAuth('/api/v1/status');
                    if (!response.ok) throw new Error('Failed to fetch status');
                    const status = await response.json();
                    
                    let html = `<li><span>Torrent Client (${status.torrent_client.type})</span><span class="media-status status-${status.torrent_client.status ? 'online' : 'offline'}">${status.torrent_client.status ? 'Online' : 'Offline'}</span></li>`;

                    for (const url in status.indexer_clients) {
                        const client = status.indexer_clients[url];
                        const displayName = client.name ? `${client.type}/${client.name}` : client.type;
                        html += `<li><span>Indexer (${displayName})</span><span class="media-status status-${client.status ? 'online' : 'offline'}">${client.status ? 'Online' : 'Offline'}</span></li>`;
                    }

                    for (const provider of status.metadata_clients) {
                        const url = metadataAPI[provider];
                        let isOnline = false;
                        if(url) {
                            try {
                                const metaResponse = await fetch(url, { mode: 'no-cors' });
                                isOnline = true;
                            } catch (e) {
                                isOnline = false;
                            }
                        }
                        html += `<li><span>Metadata (${provider})</span><span class="media-status status-${isOnline ? 'online' : 'offline'}">${isOnline ? 'Online' : 'Offline'}</span></li>`;
                    }
                    
                    statusList.innerHTML = html;
                } catch (error) {
                    statusList.innerHTML = '<li><span style="color:var(--error-color)">Failed to load system status</span></li>';
                }
            }

            async function loadAnimeSearchTerms(mediaId) {
                const list = document.getElementById('anime-search-terms-list');
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/anime-search-terms`);
                    if (!response.ok) throw new Error('Failed to load search terms');
                    const terms = await response.json();
                    if (terms && terms.length > 0) {
                        list.innerHTML = terms.map(term => `
                            <div class="search-term-tag">
                                <span>${term.term}</span>
                                <button class="danger" style="padding: 0.2rem 0.5rem;" onclick="deleteSearchTerm(${term.id}, ${mediaId})">X</button>
                            </div>
                        `).join('');
                    } else {
                        list.innerHTML = '<p>No alternative search terms found.</p>';
                    }
                } catch (error) {
                    list.innerHTML = `<p style="color:var(--error-color)">${error.message}</p>`;
                }
            }

            window.addSearchTerm = async function(mediaId) {
                const input = document.getElementById('new-search-term-input');
                const term = input.value.trim();
                if (!term) return;

                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/anime-search-terms`, {
                        method: 'POST',
                        body: { term: term }
                    });
                    if (!response.ok) throw new Error('Failed to add term');
                    input.value = '';
                    loadAnimeSearchTerms(mediaId);
                    showToast('Search term added!');
                } catch (error) {
                    showToast(error.message, 'error');
                }
            };

            window.deleteSearchTerm = async function(termId, mediaId) {
                try {
                    const response = await fetchWithAuth(`/api/v1/media/anime-search-terms/${termId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('Failed to delete term');
                    loadAnimeSearchTerms(mediaId);
                    showToast('Search term deleted!');
                } catch (error) {
                    showToast(error.message, 'error');
                }
            };

            function initializeCalendar() {
                if (state.calendar) {
                    state.calendar.refetchEvents();
                    return;
                }
                const calendarEl = document.getElementById('calendar');
                const calendar = new FullCalendar.Calendar(calendarEl, {
                    initialView: 'dayGridMonth',
                    headerToolbar: {
                        left: 'prev,next today',
                        center: 'title',
                        right: 'dayGridMonth,timeGridWeek,listWeek'
                    },
                    events: {
                        url: '/api/v1/calendar',
                        headers: {
                            'Authorization': `Bearer ${state.sessionToken}`
                        },
                        failure: function() {
                            showToast('Failed to load calendar events', 'error');
                        }
                    },
                    eventDidMount: function(info) {
                        // You can add tooltips or other interactions here
                    }
                });
                calendar.render();
                state.calendar = calendar;
            }

            // Settings page functionality
            async function loadConfig() {
                const configDisplay = document.getElementById('config-display');
                try {
                    const response = await fetchWithAuth('/api/v1/config');
                    if (response.ok) {
                        const configText = await response.text();
                        if (!state.editor) {
                            state.editor = CodeMirror.fromTextArea(configDisplay, {
                                lineNumbers: true,
                                mode: 'yaml',
                                theme: 'material-darker',
                                lineWrapping: true,
                            });
                        }
                        state.editor.setValue(configText);
                        setTimeout(() => state.editor.refresh(), 10);
                    } else {
                        configDisplay.value = 'Error loading config.';
                    }
                } catch (error) {
                    configDisplay.value = 'Error loading config.';
                }
            }

            async function saveConfig() {
                const configContent = state.editor.getValue();
                try {
                    const response = await fetchWithAuth('/api/v1/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain' },
                        body: configContent
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || 'Failed to save config');
                    }
                    showToast('Configuration saved and reloaded successfully!');
                } catch (error) {
                    showToast(`Error: ${error.message}`, 'error');
                }
            }

            // Logs Page Functionality
            let logWebSocket;
            function initializeLogViewer() {
                const logContainer = document.getElementById('log-container');
                const logFilter = document.getElementById('log-filter');
                const clearLogsBtn = document.getElementById('clear-logs-btn');
                
                logContainer.innerHTML = ''; // Clear previous logs

                // Close existing connection if it exists
                if (logWebSocket && logWebSocket.readyState < 2) {
                    logWebSocket.close();
                }
                
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/api/v1/logs/ws`;

                logWebSocket = new WebSocket(wsUrl);

                logWebSocket.onopen = () => {
                    logContainer.innerHTML += '<div style="color: var(--success-color);">[WebSocket] Connection established. Waiting for logs...</div>';
                };

                logWebSocket.onmessage = (event) => {
                    const logLine = document.createElement('div');
                    logLine.className = 'log-line';
                    logLine.textContent = event.data;
                    logContainer.appendChild(logLine);
                    logContainer.scrollTop = logContainer.scrollHeight;
                    applyLogFilter();
                };

                logWebSocket.onclose = () => {
                    logContainer.innerHTML += '<div style="color: var(--error-color);">[WebSocket] Connection closed.</div>';
                };

                logFilter.addEventListener('input', applyLogFilter);
                clearLogsBtn.addEventListener('click', () => logContainer.innerHTML = '');
            }
            function applyLogFilter() {
                const filterText = document.getElementById('log-filter').value.toLowerCase();
                document.querySelectorAll('#log-container .log-line').forEach(line => {
                    const lineVisible = line.textContent.toLowerCase().includes(filterText);
                    line.style.display = lineVisible ? '' : 'none';
                });
            }
        });
    </script>
</body>
</html>