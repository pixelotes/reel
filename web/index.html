<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎬 Reel</title>
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
    <style>
        :root {
            --bg-color: #1e1e1e; --text-color: #d4d4d4; --primary-color: #007acc;
            --border-color: #333; --header-bg: #252526; --table-header-bg: #333;
            --table-row-hover: #2a2d2e; --success-color: #4ec9b0; --error-color: #f44747;
            --warning-color: #ffcc02; --info-color: #75beff;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; }
        main { max-width: 1200px; margin: auto; padding: 2rem; }
        a { color: var(--primary-color); text-decoration: none; }
        a:hover { text-decoration: underline; }
        input, select, button, textarea { padding: 0.75rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--header-bg); color: var(--text-color); font-size: 1rem; }
        button { background-color: var(--primary-color); border-color: var(--primary-color); cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        button.secondary { background-color: var(--header-bg); color: var(--text-color); }
        button.danger { background-color: var(--error-color); border-color: var(--error-color); }

        #login-screen { display: flex; align-items: center; justify-content: center; height: 100vh; }
        #login-form { display: flex; flex-direction: column; gap: 1rem; padding: 2rem; background: var(--header-bg); border-radius: 8px; }

        #app-container { display: none; }
        nav { display: flex; gap: 1rem; border-bottom: 1px solid var(--border-color); margin-bottom: 2rem; }
        nav button { background: none; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; color: var(--text-color); border-bottom: 2px solid transparent; }
        nav button.active { border-bottom-color: var(--primary-color); }
        .page { display: none; }
        .page.active { display: block; }

        /* Media Grid Styles */
        .media-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .media-card { background: var(--header-bg); border-radius: 8px; overflow: hidden; position: relative; cursor: pointer; }
        .media-poster { width: 100%; height: 200px; background: var(--border-color); background-size: cover; background-position: center; position: relative; }
        .media-poster::after { content: '🎬'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; opacity: 0.3; }
        .media-info { padding: 1rem; }
        .media-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem; }
        .media-meta { font-size: 0.9rem; color: #aaa; margin-bottom: 0.5rem; }
        .media-status { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; }
        .status-pending { background-color: var(--warning-color); color: #000; }
        .status-searching { background-color: var(--info-color); color: #000; }
        .status-downloading { background-color: var(--primary-color); color: #fff; }
        .status-downloaded { background-color: var(--success-color); color: #000; }
        .status-failed { background-color: var(--error-color); color: #fff; }
        .status-skipped { background-color: var(--border-color); color: var(--text-color); }
        .status-tba { background-color: #555; color: var(--text-color); }
        .status-monitoring { background-color: #8a2be2; color: #fff; } /* Added for monitoring */

        .progress-bar { width: 100%; height: 4px; background: var(--border-color); margin-top: 0.5rem; border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--success-color); transition: width 0.3s ease; }

        /* Add Media Form */
        #add-media-form { background: var(--header-bg); padding: 2rem; border-radius: 8px; margin-bottom: 2rem; }
        #add-media-form .form-row { display: flex; gap: 1rem; margin-bottom: 1rem; }
        #add-media-form .form-row input, #add-media-form .form-row select { flex: 1; }
        #add-media-form .form-row.full-width { flex-direction: column; }
        #add-media-form textarea { min-height: 100px; resize: vertical; }

        /* Search Results */
        .search-results { margin-top: 1rem; }
        .search-result { display: flex; gap: 1rem; padding: 1rem; background: var(--table-row-hover); border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; }
        .search-result:hover { background: var(--border-color); }
        .search-result img { width: 60px; height: 90px; object-fit: cover; border-radius: 4px; }
        .search-result-info { flex: 1; }
        .search-result-title { font-weight: bold; }
        .search-result-meta { font-size: 0.9rem; color: #aaa; }

        /* Manual Search Results */
        .manual-search-result { display: grid; grid-template-columns: 1fr auto auto auto auto auto; gap: 1rem; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .manual-search-result:last-child { border-bottom: none; }
        .manual-search-title { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Modal Styles */
        .modal-backdrop { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal-content { background-color: var(--header-bg); margin: auto; padding: 2rem; border: 1px solid var(--border-color); width: 80%; max-width: 900px; border-radius: 8px; position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-content-video { background-color: var(--header-bg); margin: auto; padding: auto; border: 1px solid var(--border-color); width: auto; max-width: 900px; border-radius: 8px; position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-close { color: #aaa; position: absolute; top: 1rem; right: 1.5rem; font-size: 28px; font-weight: bold; cursor: pointer; z-index: 10;}
        .modal-close:hover, .modal-close:focus { color: var(--text-color); }

        /* Filter Bar */
        .filter-bar { display: flex; gap: 1rem; align-items: center; margin-bottom: 2rem; flex-wrap: wrap; }
        .filter-bar select, .filter-bar input { min-width: 150px; }
        
        /* TV Show Details */
        .season-details summary { cursor: pointer; font-weight: bold; margin: 1rem 0 0.5rem; }
        .episode-list { display: flex; flex-direction: column; gap: 0.5rem; margin-left: 1rem; }
        .episode-item { display: grid; grid-template-columns: 1fr auto auto auto; align-items: center; gap: 1rem; }

        /* Video Player Styles */
        #video-player-modal .modal-content {
            width: 90%;
            max-width: 1200px;
            padding: 1rem;
            height: auto;
            position: relative; /* Needed for absolute positioning of the close button */
        }
        .video-js.vjs-fluid, .video-js.vjs-16-9, .video-js.vjs-4-3 {
            width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-screen">
        <form id="login-form">
            <h2>🎬 Reel Login</h2>
            <input type="password" id="password-input" placeholder="Password" required>
            <button type="submit">Login</button>
            <p id="login-error" style="color:var(--error-color); text-align:center;"></p>
        </form>
    </div>

    <main id="app-container">
        <nav id="nav-buttons">
            <button data-page="media-page" class="active">Media</button>
            <button data-page="add-page">Add Media</button>
            <button data-page="settings-page">Settings</button>
        </nav>

        <div id="media-page" class="page active">
            <div class="filter-bar">
                <select id="status-filter">
                    <option value="all">All Status</option>
                    <option value="pending">Pending</option>
                    <option value="searching">Searching</option>
                    <option value="downloading">Downloading</option>
                    <option value="downloaded">Downloaded</option>
                    <option value="monitoring">Monitoring</option>
                    <option value="failed">Failed</option>
                </select>
                <select id="type-filter">
                    <option value="all">All Types</option>
                    <option value="movie">Movies</option>
                    <option value="tvshow">TV Shows</option>
                    <option value="anime">Anime</option>
                </select>
                <input type="search" id="search-filter" placeholder="Search titles...">
                <button id="refresh-btn">🔄 Refresh</button>
            </div>
            <div id="media-grid" class="media-grid"></div>
        </div>

        <div id="add-page" class="page">
            <form id="add-media-form">
                <h2>Add New Media</h2>
                
                <div class="form-row">
                    <select name="type" id="media-type" required>
                        <option value="movie">Movie</option>
                        <option value="tvshow">TV Show</option>
                        <option value="anime">Anime</option>
                    </select>
                </div>

                <div class="form-row">
                    <input type="text" name="search-query" id="search-query" placeholder="Search by title..." required>
                    <button type="button" id="search-metadata-btn">Search</button>
                </div>

                <div id="metadata-results" class="search-results"></div>

                <input type="hidden" name="id" id="id-input">

                <div class="form-row">
                    <input type="text" name="title" id="title-input" placeholder="Title" required>
                    <input type="number" name="year" id="year-input" placeholder="Year" min="1900" max="2030">
                </div>

                <div id="tv-show-options" class="form-row" style="display: none;">
                    <select name="start_season" id="start-season-select"></select>
                    <select name="start_episode" id="start-episode-select"></select>
                </div>

                <div class="form-row">
                    <select name="language" id="language-select">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                    </select>
                </div>

                <div class="form-row">
                    <select name="min_quality" id="min-quality" required>
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p" selected>720p</option>
                        <option value="1080p">1080p</option>
                        <option value="1440p">1440p</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                    <select name="max_quality" id="max-quality" required>
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p">720p</option>
                        <option value="1080p" selected>1080p</option>
                        <option value="1440p">1440p</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                </div>

                <div class="form-row">
                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="checkbox" name="auto_download" id="auto-download-checkbox" checked>
                        Start downloading automatically
                    </label>
                </div>

                <button type="submit">Add to Library</button>
                <p id="add-status" style="text-align:center; margin-top:1rem;"></p>
            </form>
        </div>

        <div id="settings-page" class="page">
            <h2>Settings</h2>
            <div style="background: var(--header-bg); padding: 2rem; border-radius: 8px;">
                <h3>Configuration</h3>
                <p>Settings are currently managed via configuration file or environment variables.</p>
                <p>Current configuration will be editable via this interface in a future update.</p>
                
                <h4>Current Status</h4>
                <div id="system-status">
                    <p><strong>Indexer Connection:</strong> <span id="indexer-status">Checking...</span></p>
                    <p><strong>Torrent Client:</strong> <span id="torrent-status">Checking...</span></p>
                    <p><strong>Metadata Provider:</strong> <span id="metadata-status">Checking...</span></p>
                </div>

                <h4>Quick Actions</h4>
                <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                    <button id="test-indexer-btn">Test Indexer Connection</button>
                    <button id="test-torrent-btn">Test Torrent Client</button>
                    <button id="clear-failed-btn" class="danger">Clear Failed Items</button>
                </div>
            </div>
        </div>
    </main>

    <div id="media-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div id="media-detail-content"></div>
        </div>
    </div>

    <div id="manual-search-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div id="manual-search-content"></div>
        </div>
    </div>

    <div id="video-player-modal" class="modal-backdrop">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <div class="reel-content">
                <video
                    id="reel-player"
                    class="video-js vjs-big-play-centered vjs-fluid"
                    controls
                    preload="auto"
                    data-setup='{"fluid": true, html5: {vtt:{allowNativeVtt: false}}}'
                >
                </video>
            </div>
        </div>
    </div>

    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // App State
            const state = {
                sessionToken: '',
                allMedia: [],
                filteredMedia: [],
                currentMediaId: null,
            };

            const RESOLUTION_RANK = {
                "360p":  0,
                "480p":  1,
                "720p":  2,
                "1080p": 3,
                "1440p": 4,
                "2160p": 5,
            };

            // DOM Elements
            const loginScreen = document.getElementById('login-screen');
            const appContainer = document.getElementById('app-container');
            const loginForm = document.getElementById('login-form');
            const mediaGrid = document.getElementById('media-grid');
            const addMediaForm = document.getElementById('add-media-form');
            const mediaTypeSelect = document.getElementById('media-type');
            const tvShowOptions = document.getElementById('tv-show-options');

            // Authentication
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const passwordInput = document.getElementById('password-input');
                const loginError = document.getElementById('login-error');
                loginError.textContent = '';
                
                try {
                    const response = await fetch('/api/v1/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ password: passwordInput.value })
                    });
                    
                    if (!response.ok) throw new Error('Incorrect password');
                    
                    const { token } = await response.json();
                    state.sessionToken = token;
                    loginScreen.style.display = 'none';
                    appContainer.style.display = 'block';
                    initializeApp();
                } catch (error) {
                    loginError.textContent = error.message;
                }
            });

            // App Initialization
            function initializeApp() {
                setupNavigation();
                setupFilters();
                setupAddMediaForm();
                setupModal();
                setupManualSearchModal();
                setupVideoPlayerModal();
                refreshData();
                checkSystemStatus();
                setInterval(refreshData, 5000);
            }

            function setupNavigation() {
                document.getElementById('nav-buttons').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        const pageId = e.target.dataset.page;
                        document.querySelector('#nav-buttons .active').classList.remove('active');
                        e.target.classList.add('active');
                        document.querySelectorAll('.page').forEach(p => p.classList.toggle('active', p.id === pageId));
                        
                        if (pageId === 'media-page') {
                            loadMedia();
                        }
                    }
                });
            }

            function setupFilters() {
                const statusFilter = document.getElementById('status-filter');
                const typeFilter = document.getElementById('type-filter');
                const searchFilter = document.getElementById('search-filter');
                const refreshBtn = document.getElementById('refresh-btn');

                [statusFilter, typeFilter, searchFilter].forEach(filter => {
                    filter.addEventListener('change', filterMedia);
                    filter.addEventListener('input', filterMedia);
                });

                refreshBtn.addEventListener('click', loadMedia);
            }

            function setupAddMediaForm() {
                const searchBtn = document.getElementById('search-metadata-btn');
                searchBtn.addEventListener('click', searchMetadata);
                addMediaForm.addEventListener('submit', addMedia);
                mediaTypeSelect.addEventListener('change', () => {
                    tvShowOptions.style.display = (mediaTypeSelect.value === 'tvshow' || mediaTypeSelect.value === 'anime') ? 'flex' : 'none';
                });
            }

            function setupModal() {
                const modal = document.getElementById('media-modal');
                const closeBtn = modal.querySelector('.modal-close');
                
                closeBtn.addEventListener('click', () => {
                    modal.style.display = 'none';
                    state.currentMediaId = null; // Clear the current media ID when closing
                });
                window.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                        state.currentMediaId = null; // Clear the current media ID when closing
                    }
                });
            }

            function setupManualSearchModal() {
                const modal = document.getElementById('manual-search-modal');
                const closeBtn = modal.querySelector('.modal-close');
                
                closeBtn.addEventListener('click', () => modal.style.display = 'none');
                window.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
            }

            function setupVideoPlayerModal() {
                const modal = document.getElementById('video-player-modal');
                const closeBtn = modal.querySelector('.modal-close');
                const player = videojs('reel-player');

                const closeModal = () => {
                    modal.style.display = 'none';
                    player.pause();
                    player.src(''); // Clear the source
                    
                    // Clean up any remaining text tracks
                    const tracks = player.remoteTextTracks();
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        player.removeRemoteTextTrack(tracks[i]);
                    }
                };

                closeBtn.addEventListener('click', closeModal);
                window.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });
                
                // Handle escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.style.display === 'flex') {
                        closeModal();
                    }
                });
            }
            
            async function refreshData() {
                const oldMediaData = JSON.stringify(state.allMedia);
                await loadMedia();
                const newMediaData = JSON.stringify(state.allMedia);

                const modal = document.getElementById('media-modal');
                if (modal.style.display === 'flex' && state.currentMediaId) {
                    if (oldMediaData !== newMediaData) {
                        const media = state.allMedia.find(m => m.id === state.currentMediaId);
                        if(media) {
                           updateMediaDetails(media);
                           updateEpisodeStatuses(state.currentMediaId);
                        }
                    }
                }
            }
            
            async function updateMediaDetails(media) {
                const modal = document.getElementById('media-modal');

                const statusEl = modal.querySelector('#detail-status');
                if (statusEl) {
                    statusEl.className = `media-status status-${media.status}`;
                    statusEl.textContent = media.status;
                }
                
                const progressContainer = modal.querySelector('#detail-progress-container');
                if(progressContainer) {
                    if (media.status === 'downloading') {
                        progressContainer.style.display = 'block';
                        modal.querySelector('#detail-progress-fill').style.width = `${media.progress * 100}%`;
                        modal.querySelector('#detail-progress-text').textContent = `Progress: ${Math.round(media.progress * 100)}%`;
                    } else {
                        progressContainer.style.display = 'none';
                    }
                }

                const torrentNameEl = modal.querySelector('#detail-torrent-name');
                if (torrentNameEl) {
                    torrentNameEl.innerHTML = media.torrent_name ? `<p><strong>${media.type === 'movie' ? 'Torrent' : 'Latest download'}:</strong> ${media.torrent_name}</p>` : '';
                }

                const completedAtEl = modal.querySelector('#detail-completed-at');
                if (completedAtEl) {
                    completedAtEl.innerHTML = media.completed_at ? `<p><strong>Completed:</strong> ${new Date(media.completed_at).toLocaleString()}</p>` : '';
                }
            }

            async function updateEpisodeStatuses(mediaId) {
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/tv-details`);
                    if (response.ok) {
                        const show = await response.json();
                        const modal = document.getElementById('media-modal');
                        show.seasons.forEach(season => {
                            season.episodes.forEach(ep => {
                                const episodeEl = modal.querySelector(`.episode-item[data-season-number="${season.season_number}"][data-episode-number="${ep.episode_number}"]`);
                                if (episodeEl) {
                                    const statusEl = episodeEl.querySelector('.media-status');
                                    if (statusEl.textContent.toLowerCase() !== ep.status.toLowerCase()) {
                                        statusEl.className = `media-status status-${ep.status}`;
                                        statusEl.textContent = ep.status;
                                    }
                                }
                            });
                        });
                    }
                } catch (e) {
                    console.error("Could not update episode statuses", e);
                }
            }


            // API Functions
            async function fetchWithAuth(url, options = {}) {
                const headers = { ...options.headers };
                headers['Authorization'] = `Bearer ${state.sessionToken}`;
                if (options.body && typeof options.body === 'object') {
                    headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(options.body);
                }
                
                const response = await fetch(url, { ...options, headers });
                if (response.status === 401) {
                    window.location.reload();
                }
                return response;
            }

            async function loadMedia() {
                try {
                    const response = await fetchWithAuth('/api/v1/media');
                    if (response.ok) {
                        const newMedia = await response.json();
                        if (JSON.stringify(newMedia) !== JSON.stringify(state.allMedia)) {
                           state.allMedia = newMedia;
                           filterMedia();
                        }
                    }
                } catch (error) {
                    console.error('Failed to load media:', error);
                }
            }

            async function addMedia(e) {
                e.preventDefault();
                const formData = new FormData(e.target);
                const statusEl = document.getElementById('add-status');
                const minQuality = formData.get('min_quality');
                const maxQuality = formData.get('max_quality');

                if (RESOLUTION_RANK[minQuality] > RESOLUTION_RANK[maxQuality]) {
                    statusEl.textContent = 'Error: Minimum quality cannot be higher than maximum quality.';
                    statusEl.style.color = 'var(--error-color)';
                    return;
                }
                
                statusEl.textContent = 'Adding media...';
                
                try {
                    const body = {
                        type: formData.get('type'),
                        title: formData.get('title'),
                        year: parseInt(formData.get('year')),
                        id: formData.get('id'),
                        language: formData.get('language'),
                        min_quality: minQuality,
                        max_quality: maxQuality,
                        auto_download: document.getElementById('auto-download-checkbox').checked,
                    };
                    
                    if (body.type === 'tvshow' || body.type === 'anime') {
                        body.start_season = parseInt(formData.get('start_season'));
                        body.start_episode = parseInt(formData.get('start_episode'));
                    }

                    const response = await fetchWithAuth('/api/v1/media', {
                        method: 'POST',
                        body: body
                    });
                    
                    if (response.ok) {
                        statusEl.textContent = 'Media added successfully!';
                        statusEl.style.color = 'var(--success-color)';
                        e.target.reset();
                        document.getElementById('metadata-results').innerHTML = '';
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to add media');
                    }
                } catch (error) {
                    statusEl.textContent = `Error: ${error.message}`;
                    statusEl.style.color = 'var(--error-color)';
                }
            }

            async function searchMetadata() {
                const query = document.getElementById('search-query').value;
                const type = document.getElementById('media-type').value;
                const resultsContainer = document.getElementById('metadata-results');
                
                if (!query) return;
                
                resultsContainer.innerHTML = '<p>Searching...</p>';
                
                try {
                    const response = await fetchWithAuth(`/api/v1/search-metadata?q=${encodeURIComponent(query)}&type=${type}`);
                    if (response.ok) {
                        const results = await response.json();
                        displayMetadataResults(results);
                    } else {
						const error = await response.json();
                        resultsContainer.innerHTML = `<p style="color:var(--error-color)">Search failed: ${error.error}</p>`;
                    }
                } catch (error) {
                    resultsContainer.innerHTML = '<p style="color:var(--error-color)">Search error</p>';
                }
            }

            function displayMetadataResults(results) {
                const container = document.getElementById('metadata-results');
                
                if (!results || results.length === 0) {
                    container.innerHTML = '<p>No results found</p>';
                    return;
                }
                
                container.innerHTML = results.map(item => `
                    <div class="search-result" onclick="selectMetadataItem(this, ${JSON.stringify(item).replace(/"/g, '&quot;')})">
                        ${item.poster_url ? `<img src="${item.poster_url}" alt="${item.title}">` : '<div style="width:60px;height:90px;background:var(--border-color);border-radius:4px;"></div>'}
                        <div class="search-result-info">
                            <div class="search-result-title">${item.title}</div>
                            <div class="search-result-meta">${item.year} • ${item.overview ? item.overview.substring(0, 100) + '...' : 'No description'}</div>
                        </div>
                    </div>
                `).join('');
            }

            window.selectMetadataItem = function(element, item) {
                document.getElementById('title-input').value = item.title;
                document.getElementById('year-input').value = item.year;
                document.getElementById('id-input').value = item.id;
                document.getElementById('metadata-results').innerHTML = '';

                if (mediaTypeSelect.value === 'tvshow' || mediaTypeSelect.value === 'anime') {
                    populateTVEpisodeSelectors(item.seasons);
                }
            };
            
            function populateTVEpisodeSelectors(seasons) {
                const seasonSelect = document.getElementById('start-season-select');
                const episodeSelect = document.getElementById('start-episode-select');
                seasonSelect.innerHTML = '';
                episodeSelect.innerHTML = '';

                const seasonNumbers = Object.keys(seasons).map(Number).sort((a,b) => a - b);
                
                for (const seasonNum of seasonNumbers) {
                    seasonSelect.innerHTML += `<option value="${seasonNum}">Season ${seasonNum}</option>`;
                }
                
                function updateEpisodes() {
                    const selectedSeason = seasonSelect.value;
                    episodeSelect.innerHTML = '';
                    if (seasons[selectedSeason]) {
                        seasons[selectedSeason].forEach(ep => {
                            episodeSelect.innerHTML += `<option value="${ep.episode_number}">Episode ${ep.episode_number} - ${ep.title}</option>`;
                        });
                    }
                }
                
                seasonSelect.addEventListener('change', updateEpisodes);
                updateEpisodes();
            }

            async function checkSystemStatus() {
                try {
                    const response = await fetchWithAuth('/api/v1/status');
                    if (response.ok) {
                        const status = await response.json();
                        document.getElementById('indexer-status').textContent = status.indexer ? 'Connected' : 'Disconnected';
                        document.getElementById('torrent-status').textContent = status.torrent_client ? 'Connected' : 'Disconnected';
                        document.getElementById('metadata-status').textContent = status.metadata ? 'Connected' : 'Disconnected';
                    }
                } catch (error) {
                    console.error('Failed to check system status:', error);
                }
            }

            function filterMedia() {
                const statusFilter = document.getElementById('status-filter').value;
                const typeFilter = document.getElementById('type-filter').value;
                const searchFilter = document.getElementById('search-filter').value.toLowerCase();
                
                state.filteredMedia = state.allMedia.filter(media => {
                    if (statusFilter !== 'all' && media.status !== statusFilter) return false;
                    if (typeFilter !== 'all' && media.type !== typeFilter) return false;
                    if (searchFilter && !media.title.toLowerCase().includes(searchFilter)) return false;
                    return true;
                });
                
                renderMediaGrid();
            }

            function renderMediaGrid() {
                if (!state.allMedia) {
                    mediaGrid.innerHTML = '<p style="text-align:center; padding:2rem; color:#aaa;">Loading media...</p>';
                    return
                }

                if (state.filteredMedia.length === 0) {
                    mediaGrid.innerHTML = '<p style="text-align:center; padding:2rem; color:#aaa;">No media found. Add some media to get started!</p>';
                    return;
                }
                
                mediaGrid.innerHTML = state.filteredMedia.map(media => `
                    <div class="media-card" data-media-id="${media.id}">
                        <div class="media-poster" style="${media.poster_url ? `background-image: url('${media.poster_url}')` : ''}"></div>
                        <div class="media-info">
                            <div class="media-title">${media.title}</div>
                            <div class="media-meta">${media.year} • ${media.type.charAt(0).toUpperCase() + media.type.slice(1)}</div>
                            <span class="media-status status-${media.status}">${media.status}</span>
                            ${media.status === 'downloading' ? `
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${media.progress * 100}%"></div>
                                </div>
                                <div style="font-size: 0.8rem; margin-top: 0.25rem;">${Math.round(media.progress * 100)}%</div>
                            ` : ''}
                        </div>
                    </div>
                `).join('');

                // Add event listeners after rendering
                document.querySelectorAll('.media-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const mediaId = card.dataset.mediaId;
                        showMediaDetails(parseInt(mediaId));
                    });
                });
            }

            function srt2webvtt(srt) {
                const webvtt = "WEBVTT\n\n" + srt
                    .replace(/(\d+)\s*\n/g, '')
                    .replace(/(\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1.$2')
                    .trim()
                return webvtt;
            }

            async function showMediaDetails(mediaId) {
                state.currentMediaId = mediaId;
                const media = state.allMedia.find(m => m.id === mediaId);
                if (!media) return;
                
                const modal = document.getElementById('media-modal');
                const content = document.getElementById('media-detail-content');
                content.innerHTML = '<h2>Loading...</h2>';
                modal.style.display = 'flex';

                let tvShowDetailsHtml = '';
                if (media.type === 'tvshow' || media.type === 'anime') {
                    try {
                        const response = await fetchWithAuth(`/api/v1/media/${mediaId}/tv-details`);
                        if (response.ok) {
                            const show = await response.json();
                            tvShowDetailsHtml = `
                                <h4>Seasons</h4>
                                <div style="max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 4px;">
                                ${show.seasons.map(season => `
                                    <details class="season-details" data-season-number="${season.season_number}">
                                        <summary>Season ${season.season_number} <button class="secondary" onclick="searchSeasonPack(${media.id}, ${season.season_number})">Search Season Pack</button></summary>
                                        <div class="episode-list">
                                            ${season.episodes.map(ep => `
                                                <div class="episode-item" data-season-number="${season.season_number}" data-episode-number="${ep.episode_number}">
                                                    <span>${ep.episode_number}. ${ep.title} <em style="color:#aaa; font-size: 0.8rem;">(${ep.air_date})</em></span>
                                                    <span class="media-status status-${ep.status}">${ep.status}</span>
                                                
                                                    <button class="secondary" onclick="manualEpisodeSearch(${media.id}, ${season.season_number}, ${ep.episode_number})">🔍</button>
                                                    <button class="secondary" ${ep.status === 'downloaded' ? `enabled` : `disabled style="border-color: red; opacity: 0.4; filter: alpha(opacity=40);"`} onclick="playVideo(${media.id}, ${season.season_number}, ${ep.episode_number})">▶️</button>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </details>
                                `).join('')}
                                </div>
                            `;
                        }
                    } catch (e) {
                        tvShowDetailsHtml = '<p style="color:var(--error-color)">Could not load season details.</p>';
                    }
                }
                
                content.innerHTML = `
                    <h2>${media.title} (${media.year}) ${media.status === 'downloaded' ? `<button class="secondary" style="font-size: 1rem; padding: 0.2rem 0.5rem;" onclick="playVideo(${media.id})">▶️ Play</button>` : ''}</h2>
                    <div style="display: flex; gap: 2rem; margin-bottom: 2rem;">
                        ${media.poster_url ? `<img src="${media.poster_url}" alt="${media.title}" style="width: 200px; border-radius: 8px;">` : ''}
                        <div style="flex: 1;">
                            <p><strong>Type:</strong> ${media.type.charAt(0).toUpperCase() + media.type.slice(1)}</p>
                            <p><strong>Language:</strong> ${media.language ? media.language.toUpperCase() : 'N/A'}</p>
                            <p><strong>Quality Range:</strong> ${media.min_quality} - ${media.max_quality}</p>
                            <p><strong>Status:</strong> <span id="detail-status" class="media-status status-${media.status}">${media.status}</span></p>
                            <div id="detail-progress-container" style="display: ${media.status === 'downloading' ? 'block' : 'none'};">
                                <div class="progress-bar" style="height: 10px;">
                                    <div id="detail-progress-fill" class="progress-fill" style="width: ${media.progress * 100}%"></div>
                                </div>
                                <p id="detail-progress-text"><strong>Progress:</strong> ${Math.round(media.progress * 100)}%</p>
                            </div>
                            ${media.tmdb_id ? `<p><strong>TMDB ID:</strong> ${media.tmdb_id}</p>` : ''}
                            <div id="detail-torrent-name">${media.torrent_name ? `<p><strong>${media.type === 'movie' ? 'Torrent' : 'Latest download'}:</strong> ${media.torrent_name}</p>` : ''}</div>
                            <p><strong>Added:</strong> ${new Date(media.added_at).toLocaleString()}</p>
                            <div id="detail-completed-at">${media.completed_at ? `<p><strong>Completed:</strong> ${new Date(media.completed_at).toLocaleString()}</p>` : ''}</div>
                        </div>
                    </div>
                    ${media.overview ? `<p><strong>Overview:</strong></p><div style="max-height: 100px; overflow-y: auto;">${media.overview}</div>` : ''}
                    
                    ${tvShowDetailsHtml}

                    <div id="manual-search-container" style="margin-top: 2rem;"></div>

                    <div style="display: flex; gap: 1rem; margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                        ${media.status !== 'downloading' && media.status !== 'downloaded' ? `<button onclick="manualMovieSearch(${media.id})">🔍 Manual Search</button>` : ''}
                        ${media.status === 'failed' || media.status === 'pending' ? `<button onclick="retryMedia(${media.id})">🔄 Retry</button>` : ''}
                        <button onclick="deleteMedia(${media.id})" class="danger">🗑️ Delete</button>
                    </div>
                `;
            };
            
            window.playVideo = function(mediaId, seasonNumber = 0, episodeNumber = 0) {
                const modal = document.getElementById('video-player-modal');
                const player = videojs('reel-player');

                // Clear any existing text tracks
                const existingTracks = player.remoteTextTracks();
                for (let i = existingTracks.length - 1; i >= 0; i--) {
                    player.removeRemoteTextTrack(existingTracks[i]);
                }

                // Set up video source
                let videoUrl = `/api/v1/stream/video/${mediaId}`;
                if (seasonNumber > 0 && episodeNumber > 0) {
                    videoUrl += `?season=${seasonNumber}&episode=${episodeNumber}`;
                }

                player.src({ src: videoUrl, type: 'video/mp4' });
                
                // Wait for player to be ready before adding subtitles
                player.ready(() => {
                    loadAllSubtitles(player, mediaId, seasonNumber, episodeNumber);
                });

                modal.style.display = 'flex';
                player.play();
            };

            async function loadAllSubtitles(player, mediaId, seasonNumber, episodeNumber) {
                try {
                    // First, get the list of available subtitles
                    let subtitlesListUrl = `/api/v1/subtitles/${mediaId}/available`;
                    const params = new URLSearchParams();
                    
                    if (seasonNumber > 0) params.append('season', seasonNumber);
                    if (episodeNumber > 0) params.append('episode', episodeNumber);
                    
                    if (params.toString()) {
                        subtitlesListUrl += '?' + params.toString();
                    }

                    const subtitlesListResponse = await fetchWithAuth(subtitlesListUrl);
                    if (!subtitlesListResponse.ok) {
                        console.log('No subtitles available for this video');
                        return;
                    }

                    const availableSubtitles = await subtitlesListResponse.json();
                    if (!availableSubtitles || availableSubtitles.length === 0) {
                        console.log('No subtitles available for this video');
                        return;
                    }

                    console.log('Available subtitles:', availableSubtitles);

                    // Load each subtitle track
                    const trackPromises = availableSubtitles.map(async (subtitle, index) => {
                        try {
                            // Build subtitle URL for each language
                            let subUrl = `/api/v1/stream/subtitles/${mediaId}`;
                            const subParams = new URLSearchParams();
                            
                            if (seasonNumber > 0) subParams.append('season', seasonNumber);
                            if (episodeNumber > 0) subParams.append('episode', episodeNumber);
                            subParams.append('lang', subtitle.language);
                            
                            if (subParams.toString()) {
                                subUrl += '?' + subParams.toString();
                            }

                            const response = await fetchWithAuth(subUrl);
                            if (!response.ok) {
                                console.warn(`Failed to load ${subtitle.label} subtitles`);
                                return null;
                            }

                            const vttContent = await response.text();
                            
                            // Create blob URL for the VTT content
                            const vttBlob = new Blob([vttContent], { type: 'text/vtt' });
                            const vttUrl = URL.createObjectURL(vttBlob);
                            
                            // Add the subtitle track
                            const track = player.addRemoteTextTrack({
                                kind: 'subtitles',
                                src: vttUrl,
                                srclang: subtitle.language,
                                label: subtitle.label,
                                default: index === 0 // Make the first subtitle track (should be English) default
                            }, false);
                            
                            console.log(`Loaded ${subtitle.label} subtitles successfully`);
                            
                            return {
                                track: track,
                                vttUrl: vttUrl
                            };
                        } catch (error) {
                            console.warn(`Failed to load ${subtitle.label} subtitles:`, error);
                            return null;
                        }
                    });

                    // Wait for all subtitle tracks to load
                    const loadedTracks = await Promise.all(trackPromises);
                    const successfulTracks = loadedTracks.filter(track => track !== null);

                    if (successfulTracks.length > 0) {
                        console.log(`Successfully loaded ${successfulTracks.length} subtitle tracks`);
                        
                        // Clean up blob URLs when video ends or player is disposed
                        player.one(['dispose', 'ended'], () => {
                            successfulTracks.forEach(trackInfo => {
                                URL.revokeObjectURL(trackInfo.vttUrl);
                            });
                        });
                    }

                } catch (error) {
                    console.log('Could not load subtitles:', error);
                }
            }

            function loadSubtitles(player, mediaId, seasonNumber, episodeNumber) {
                // Build subtitle URL
                let subUrl = `/api/v1/stream/subtitles/${mediaId}`;
                const params = new URLSearchParams();
                
                if (seasonNumber > 0) params.append('season', seasonNumber);
                if (episodeNumber > 0) params.append('episode', episodeNumber);
                params.append('lang', 'en');
                
                if (params.toString()) {
                    subUrl += '?' + params.toString();
                }

                // Fetch and add subtitles
                fetchWithAuth(subUrl)
                    .then(response => {
                        if (!response.ok) {
                            console.log('No subtitles available for this video');
                            return;
                        }
                        return response.text();
                    })
                    .then(vttContent => {
                        if (!vttContent) return;
                        
                        // Create blob URL for the VTT content
                        const vttBlob = new Blob([vttContent], { type: 'text/vtt' });
                        const vttUrl = URL.createObjectURL(vttBlob);
                        
                        // Add the subtitle track
                        const track = player.addRemoteTextTrack({
                            kind: 'subtitles',
                            src: vttUrl,
                            srclang: 'en',
                            label: 'English',
                            default: true // Make this the default subtitle track
                        }, false); // false = don't add to the DOM, let Video.js handle it
                        
                        console.log('Subtitles loaded successfully');
                        
                        // Clean up blob URL when video ends or player is disposed
                        player.one('dispose', () => {
                            URL.revokeObjectURL(vttUrl);
                        });
                    })
                    .catch(error => {
                        console.log('Could not load subtitles:', error);
                    });
            }

            window.manualMovieSearch = async function(mediaId) {
                const modal = document.getElementById('manual-search-modal');
                const content = document.getElementById('manual-search-content');
                content.innerHTML = '<p>Searching for torrents...</p>';
                modal.style.display = 'flex';

                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/search`);
                    if (!response.ok) throw new Error('Search request failed');

                    const results = await response.json();
                    displayManualSearchResultsInModal(results, (result) => manualDownload(mediaId, result));
                } catch (error) {
                    content.innerHTML = `<p style="color:var(--error-color)">Error performing search: ${error.message}</p>`;
                }
            };

            window.manualEpisodeSearch = async function(mediaId, seasonNumber, episodeNumber) {
                const modal = document.getElementById('manual-search-modal');
                const content = document.getElementById('manual-search-content');
                content.innerHTML = '<p>Searching for torrents...</p>';
                modal.style.display = 'flex';

                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/season/${seasonNumber}/episode/${episodeNumber}/search`);
                    if (!response.ok) throw new Error('Search request failed');

                    const results = await response.json();
                    displayManualSearchResultsInModal(results, (result) => manualEpisodeDownload(mediaId, seasonNumber, episodeNumber, result));
                } catch (error) {
                    content.innerHTML = `<p style="color:var(--error-color)">Error performing search: ${error.message}</p>`;
                }
            };

            window.searchSeasonPack = function(mediaId, seasonNumber) {
                alert(`Season pack search for media ID ${mediaId}, season ${seasonNumber} is not implemented yet.`);
            };

            function displayManualSearchResultsInModal(results, downloadCallback) {
                const content = document.getElementById('manual-search-content');
                if (!results || results.length === 0) {
                    content.innerHTML = '<p>No results found.</p>';
                    return;
                }

                const resultsHtml = results.map(r => {
                    const sizeMB = (r.Size / (1024 * 1024)).toFixed(2);
                    const escapedResult = JSON.stringify(r).replace(/'/g, "\\'");

                    return `
                        <div class="manual-search-result">
                            <span class="manual-search-title" title="${r.Title}">${r.Title}</span>
                            <span>${sizeMB} MB</span>
                            <span style="color: var(--success-color);">▲ ${r.Seeders}</span>
                            <span style="color: var(--error-color);">▼ ${r.Leechers}</span>
                            <span>${r.Score}</span>
                            <button class="secondary" style="font-size: 0.8rem; padding: 0.2rem 0.4rem;" data-result='${escapedResult}'>Download</button>
                        </div>
                    `;
                }).join('');

                content.innerHTML = `
                    <h4>Manual Search Results</h4>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); padding: 0 1rem; border-radius: 4px;">
                        ${resultsHtml}
                    </div>
                `;

                content.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', () => {
                        const result = JSON.parse(button.dataset.result);
                        downloadCallback(result);
                    });
                });
            }

            window.manualDownload = async function(mediaId, result) {
                if (!confirm(`Are you sure you want to download:\n\n${result.Title}`)) return;

                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/download`, {
                        method: 'POST',
                        body: result
                    });

                    if (!response.ok) throw new Error('Failed to send to download client');
                    
                    alert('Torrent sent to download client successfully!');
                    document.getElementById('manual-search-modal').style.display = 'none';
                    loadMedia(); // Refresh the media list
                } catch (error) {
                    alert(`Error: ${error.message}`);
                }
            };

            window.manualEpisodeDownload = async function(mediaId, seasonNumber, episodeNumber, result) {
                if (!confirm(`Are you sure you want to download:\n\n${result.Title}`)) return;

                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/season/${seasonNumber}/episode/${episodeNumber}/download`, {
                        method: 'POST',
                        body: result
                    });

                    if (!response.ok) throw new Error('Failed to send to download client');
                    
                    alert('Torrent sent to download client successfully!');
                    document.getElementById('manual-search-modal').style.display = 'none';
                    loadMedia(); // Refresh the media list
                } catch (error) {
                    alert(`Error: ${error.message}`);
                }
            };

            window.retryMedia = async function(mediaId) {
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}/retry`, { method: 'POST' });
                    if (response.ok) {
                        loadMedia();
                        document.getElementById('media-modal').style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to retry media:', error);
                }
            };

            window.deleteMedia = async function(mediaId) {
                if (!confirm('Are you sure you want to delete this media item?')) return;
                
                try {
                    const response = await fetchWithAuth(`/api/v1/media/${mediaId}`, { method: 'DELETE' });
                    if (response.ok) {
                        state.allMedia = state.allMedia.filter(m => m.id !== mediaId);
                        filterMedia();
                        document.getElementById('media-modal').style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to delete media:', error);
                }
            };

            // Settings page functionality
            document.getElementById('test-indexer-btn').addEventListener('click', async () => {
                const btn = document.getElementById('test-indexer-btn');
                btn.textContent = 'Testing...';
                btn.disabled = true;
                
                try {
                    const response = await fetchWithAuth('/api/v1/test/indexer');
                    const result = await response.json();
                    btn.textContent = result.ok ? '✅ Connected' : '❌ Failed';
                } catch (error) {
                    btn.textContent = '❌ Error';
                } finally {
                    setTimeout(() => {
                        btn.textContent = 'Test Indexer Connection';
                        btn.disabled = false;
                    }, 2000);
                }
            });

            document.getElementById('test-torrent-btn').addEventListener('click', async () => {
                const btn = document.getElementById('test-torrent-btn');
                btn.textContent = 'Testing...';
                btn.disabled = true;
                
                try {
                    const response = await fetchWithAuth('/api/v1/test/torrent');
                    const result = await response.json();
                    btn.textContent = result.ok ? '✅ Connected' : '❌ Failed';
                } catch (error) {
                    btn.textContent = '❌ Error';
                } finally {
                    setTimeout(() => {
                        btn.textContent = 'Test Torrent Client';
                        btn.disabled = false;
                    }, 2000);
                }
            });

            document.getElementById('clear-failed-btn').addEventListener('click', async () => {
                if (!confirm('Clear all failed media items?')) return;
                
                try {
                    const response = await fetchWithAuth('/api/v1/media/clear-failed', { method: 'POST' });
                    if (response.ok) {
                        loadMedia();
                    }
                } catch (error) {
                    console.error('Failed to clear failed items:', error);
                }
            });
        });
    </script>
</body>
</html>